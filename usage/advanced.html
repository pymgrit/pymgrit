

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Advanced usage &mdash; PyMGRIT 1.0.5 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Dahlquist" href="../applications/dahlquist.html" />
    <link rel="prev" title="Parallelism" href="parallelism.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> PyMGRIT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallelism.html">Parallelism</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Advanced usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#advanced-multigrid-hierarchy">Advanced multigrid hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spatial-coarsening">Spatial coarsening</a></li>
<li class="toctree-l2"><a class="reference internal" href="#convergence-criteria">Convergence criteria</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../applications/dahlquist.html">Dahlquist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/brusselator.html">Brusselator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/arenstorf_orbit.html">Arenstorf orbit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/heat_equation.html">Heat Equation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/advection.html">Advection</a></li>
</ul>
<p class="caption"><span class="caption-text">Coupling</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../coupling/firedrake.html">Firedrake</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coupling/petsc.html">PETSc</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyMGRIT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Advanced usage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/usage/advanced.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="advanced-usage">
<h1>Advanced usage<a class="headerlink" href="#advanced-usage" title="Permalink to this headline">¶</a></h1>
<p>This page contains short examples that demonstrate advanced usage of PyMGRIT.
The source code for these and more examples is available in the <a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples">examples</a> folder.</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#advanced-multigrid-hierarchy">Advanced multigrid hierarchy</a></p></li>
<li><p><a class="reference internal" href="#spatial-coarsening">Spatial coarsening</a></p></li>
<li><p><a class="reference internal" href="#convergence-criteria">Convergence criteria</a></p></li>
</ul>
</div></blockquote>
<div class="section" id="advanced-multigrid-hierarchy">
<h2>Advanced multigrid hierarchy<a class="headerlink" href="#advanced-multigrid-hierarchy" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_time_integrators.py">example_time_integrators.py</a> and <a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_heat_1d_bdf2.py">example_heat_1d_bdf2.py</a></p>
<p>PyMGRIT allows using different application classes and/or time integration schemes in the multigrid hierarchy.</p>
<ul class="simple">
<li><p>Example 1 shows how to implement different time integration methods in an application class.</p></li>
<li><p>Example 2 shows how to use multiple application classes in the multigrid hierarchy.</p></li>
</ul>
<p><strong>Example 1</strong> One application class with different time integration methods</p>
<p>The member function <cite>step()</cite> of an application class can carry out a time integration step based on different time
integration methods. The <a class="reference external" href="https://github.com/pymgrit/pymgrit/blob/master/src/pymgrit/dahlquist/dahlquist.py">Dahlquist
application class</a> implements the following time integration schemes:</p>
<ul class="simple">
<li><p>Backward Euler</p></li>
<li><p>Forward Euler</p></li>
<li><p>Trapezoidal rule</p></li>
<li><p>Implicit mid-point rule</p></li>
</ul>
<p>that can be controlled by the member variable <cite>method</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_start</span><span class="p">:</span> <span class="n">VectorDahlquist</span><span class="p">,</span> <span class="n">t_start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorDahlquist</span><span class="p">:</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Time integration routine for Dahlquist&#39;s test problem:</span>
<span class="sd">    BE: Backward Euler</span>
<span class="sd">    FE: Forward Euler</span>
<span class="sd">    TR: Trapezoidal rule</span>
<span class="sd">    MR: implicit Mid-point rule</span>

<span class="sd">:param u_start: approximate solution for the input time t_start</span>
<span class="sd">:param t_start: time associated with the input approximate solution u_start</span>
<span class="sd">:param t_stop: time to evolve the input approximate solution to</span>
<span class="sd">:return: approximate solution for the input time t_stop</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Note: lambda = -1</span>
<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;BE&#39;</span><span class="p">:</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;FE&#39;</span><span class="p">:</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;TR&#39;</span><span class="p">:</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;MR&#39;</span><span class="p">:</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">k1</span>
<span class="k">return</span> <span class="n">VectorDahlquist</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
</pre></div>
</div>
<p>The corresponding example (<a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_time_integrators.py">example_time_integrators.py</a>) creates a two-level hierarchy for Dahlquist’s test problem, using the implicit mid-point
rule on the fine grid (level 0) and backward Euler on the coarse grid (level 1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Dahlquist&#39;s test problem using implicit mid-point rule time integration</span>
<span class="n">dahlquist_lvl0</span> <span class="o">=</span> <span class="n">Dahlquist</span><span class="p">(</span><span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;MR&#39;</span><span class="p">)</span>
<span class="c1"># Create Dahlquist&#39;s test problem using backward Euler time integration</span>
<span class="n">dahlquist_lvl1</span> <span class="o">=</span> <span class="n">Dahlquist</span><span class="p">(</span><span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;BE&#39;</span><span class="p">)</span>

<span class="c1"># Setup an MGRIT solver and solve the problem</span>
<span class="n">mgrit</span> <span class="o">=</span> <span class="n">Mgrit</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="p">[</span><span class="n">dahlquist_lvl0</span><span class="p">,</span> <span class="n">dahlquist_lvl1</span><span class="p">])</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">mgrit</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Example 2</strong> Two application classes</p>
<p>In the second example, we use two application classes for implementing two different
time integration methods for the 1D heat equation example:</p>
<ul class="simple">
<li><p>Application class 1 implements <a class="reference external" href="https://github.com/pymgrit/pymgrit/blob/master/src/pymgrit/heat/heat_1d_2pts_bdf2.py">BDF2</a>.</p></li>
<li><p>Application class 2 implements <a class="reference external" href="https://github.com/pymgrit/pymgrit/blob/master/src/pymgrit/heat/heat_1d_2pts_bdf1.py">BDF1</a>.</p></li>
</ul>
<p>Note: The <a class="reference external" href="https://github.com/pymgrit/pymgrit/blob/master/src/pymgrit/heat/vector_heat_1d_2pts.py">vector class</a> used in both application classes contains the solution at two consecutive time points.</p>
<p>The corresponding example (<a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_heat_1d_bdf2.py">example_heat_1d_bdf2.py</a>) constructs a three-level multigrid hierarchy for the 1D heat
equation example using the BDF2 application class on the fine grid (level 0) and the BDF1 application class on the
first and second coarse grids (levels 1 and 2):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pymgrit.core.mgrit</span> <span class="kn">import</span> <span class="n">Mgrit</span>
<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d_2pts_bdf1</span> <span class="kn">import</span> <span class="n">Heat1DBDF1</span>
<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d_2pts_bdf2</span> <span class="kn">import</span> <span class="n">Heat1DBDF2</span>


<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Right-hand side of 1D heat equation example problem at a given space-time point (x,t),</span>
<span class="sd">      -sin(pi*x)(sin(t) - a*pi^2*cos(t)),  a = 1</span>

<span class="sd">    :param x: spatial grid point</span>
<span class="sd">    :param t: time point</span>
<span class="sd">    :return: right-hand side of 1D heat equation example problem at point (x,t)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">init_cond</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initial condition of 1D heat equation example,</span>
<span class="sd">      u(x,0)  = sin(pi*x)</span>

<span class="sd">    :param x: spatial grid point</span>
<span class="sd">    :return: initial condition of 1D heat equation example problem</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<span class="c1"># Time interval</span>
<span class="n">t_start</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">t_stop</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">nt</span> <span class="o">=</span> <span class="mi">512</span>  <span class="c1"># number of time points excluding t_start</span>
<span class="n">dtau</span> <span class="o">=</span> <span class="n">t_stop</span> <span class="o">/</span> <span class="n">nt</span>  <span class="c1"># time-step size</span>

<span class="c1"># Time points are grouped in pairs of two consecutive time points</span>
<span class="c1">#   =&gt; (nt/2) + 1 pairs</span>
<span class="c1"># Note: * Each pair is associated with the time value of its first point.</span>
<span class="c1">#       * The second value of the last pair (associated with t_stop) is not used.</span>
<span class="c1">#       * The spacing within each pair is the same (= dt) on all grid levels.</span>
<span class="n">t_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nt</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">heat0</span> <span class="o">=</span> <span class="n">Heat1DBDF2</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtau</span><span class="o">=</span><span class="n">dtau</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_cond</span><span class="o">=</span><span class="n">init_cond</span><span class="p">,</span>
                   <span class="n">t_interval</span><span class="o">=</span><span class="n">t_interval</span><span class="p">)</span>
<span class="n">heat1</span> <span class="o">=</span> <span class="n">Heat1DBDF1</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtau</span><span class="o">=</span><span class="n">dtau</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_cond</span><span class="o">=</span><span class="n">init_cond</span><span class="p">,</span>
                   <span class="n">t_interval</span><span class="o">=</span><span class="n">heat0</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat2</span> <span class="o">=</span> <span class="n">Heat1DBDF1</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtau</span><span class="o">=</span><span class="n">dtau</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_cond</span><span class="o">=</span><span class="n">init_cond</span><span class="p">,</span>
                   <span class="n">t_interval</span><span class="o">=</span><span class="n">heat1</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># Setup three-level MGRIT solver and solve the problem</span>
<span class="n">problem</span> <span class="o">=</span> <span class="p">[</span><span class="n">heat0</span><span class="p">,</span> <span class="n">heat1</span><span class="p">,</span> <span class="n">heat2</span><span class="p">]</span>
<span class="n">mgrit</span> <span class="o">=</span> <span class="n">Mgrit</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="n">problem</span><span class="p">)</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">mgrit</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="spatial-coarsening">
<h2>Spatial coarsening<a class="headerlink" href="#spatial-coarsening" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_spatial_coarsening.py">example_spatial_coarsening.py</a></p>
<p>This example demonstrates how to use the transfer parameter <cite>transfer</cite> of the MGRIT solver to apply spatial
coarsening on different levels of the time-grid hierarchy for solving a 1D heat equation problem (see <a class="reference internal" href="../applications/heat_equation.html"><span class="doc">Heat Equation</span></a>).</p>
<p>The first step is to import all necessary PyMGRIT classes (and <code class="docutils literal notranslate"><span class="pre">numpy</span></code> for later use):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d</span> <span class="kn">import</span> <span class="n">Heat1D</span>  <span class="c1"># 1D Heat equation problem</span>
<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d</span> <span class="kn">import</span> <span class="n">VectorHeat1D</span>  <span class="c1"># 1D Heat equation vector class</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.mgrit</span> <span class="kn">import</span> <span class="n">Mgrit</span>  <span class="c1"># MGRIT solver</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.grid_transfer</span> <span class="kn">import</span> <span class="n">GridTransfer</span>  <span class="c1"># Parent grid transfer class</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.grid_transfer_copy</span> <span class="kn">import</span> <span class="n">GridTransferCopy</span>  <span class="c1"># Copy transfer class</span>
</pre></div>
</div>
<p>Then, we define the class GridTransferHeat for the 1D heat equation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GridTransferHeat</span><span class="p">(</span><span class="n">GridTransfer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Grid Transfer for the Heat Equation.</span>
<span class="sd">    Interpolation: Linear interpolation</span>
<span class="sd">    Restriction: Full weighting</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>
<span class="sd">        :rtype: GridTransferHeat object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</pre></div>
</div>
<p>The grid transfer class must contain the two member functions <cite>restriction()</cite> and <cite>interpolation()</cite>.</p>
<p>The function <cite>restriction()</cite> receives a <cite>VectorHeat1D</cite> object and returns another <cite>VectorHeat1D</cite> object that contains
the restricted solution vector:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorHeat1D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorHeat1D</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Restrict input vector u using standard full weighting restriction.</span>

<span class="sd">    Note: In the 1d heat equation example, we consider homogeneous Dirichlet BCs in space.</span>
<span class="sd">          The Heat1D vector class only stores interior points.</span>
<span class="sd">    :param u: approximate solution vector</span>
<span class="sd">    :return: input solution vector u restricted to a coarse grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get values at interior points</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

    <span class="c1"># Create array for restricted values</span>
    <span class="n">ret_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Full weighting restriction</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)):</span>
        <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>

    <span class="c1"># Create and return a VectorHeat1D object with the restricted values</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">VectorHeat1D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">))</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>
</pre></div>
</div>
<p>Similarly, we define the function <cite>interpolation()</cite> as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorHeat1D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorHeat1D</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate input vector u using linear interpolation.</span>

<span class="sd">    Note: In the 1d heat equation example, we consider homogeneous Dirichlet BCs in space.</span>
<span class="sd">          The Heat1D vector class only stores interior points.</span>
<span class="sd">    :param u: approximate solution vector</span>
<span class="sd">    :return: input solution vector u interpolated to a fine grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get values at interior points</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

    <span class="c1"># Create array for interpolated values</span>
    <span class="n">ret_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Linear interpolation</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)):</span>
        <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Create and return a VectorHeat1D object with interpolated values</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">VectorHeat1D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">))</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>
</pre></div>
</div>
<p>Now, we construct a multigrid hierarchy for the 1d heat example. Here, we set up the following hierarchy:</p>
<blockquote>
<div><ul class="simple">
<li><p>level 0: 129 time points, 17 points in space</p></li>
<li><p>level 1: 65 time points, 9 points in space</p></li>
<li><p>level 2: 33 time points, 5 points in space</p></li>
<li><p>level 3: 17 time points, 5 points in space</p></li>
</ul>
</div></blockquote>
<p>Note: In this example, it is not possible to use PyMGRIT’s core function <cite>simple_setup_problem()</cite>, since the number of
spatial grid points changes in the multigrid hiearchy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">init_cond</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<span class="n">heat0</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_cond</span><span class="o">=</span><span class="n">init_cond</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
               <span class="n">nt</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">heat1</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_cond</span><span class="o">=</span><span class="n">init_cond</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat0</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat2</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_cond</span><span class="o">=</span><span class="n">init_cond</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat1</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat3</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_cond</span><span class="o">=</span><span class="n">init_cond</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat2</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>

<span class="n">problem</span> <span class="o">=</span> <span class="p">[</span><span class="n">heat0</span><span class="p">,</span> <span class="n">heat1</span><span class="p">,</span> <span class="n">heat2</span><span class="p">,</span> <span class="n">heat3</span><span class="p">]</span>
</pre></div>
</div>
<p>Before we can set up the MGRIT solver, we have to define the grid transfer between all two consecutive levels in the
multigrid hierarchy. These grid transfers are specified by a list of grid transfer objects of length (#levels -1).
For our four-level example, this list is of length three with two objects of the new class <cite>GridTransferHeat</cite> for the
transfer between levels 0 and 1 as well as between levels 1 and 2 and an object of PyMGRIT’s core class
<cite>GridTransferCopy</cite> for the transfer between levels 2 and 3:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">transfer</span> <span class="o">=</span> <span class="p">[</span><span class="n">GridTransferHeat</span><span class="p">(),</span> <span class="n">GridTransferHeat</span><span class="p">(),</span> <span class="n">GridTransferCopy</span><span class="p">()]</span>
</pre></div>
</div>
<p>Finally, we set up the MGRIT solver and solve the problem:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mgrit</span> <span class="o">=</span> <span class="n">Mgrit</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="n">problem</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="n">transfer</span><span class="p">)</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">mgrit</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Complete code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d</span> <span class="kn">import</span> <span class="n">Heat1D</span>  <span class="c1"># 1D Heat equation problem</span>
<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d</span> <span class="kn">import</span> <span class="n">VectorHeat1D</span>  <span class="c1"># 1D Heat equation vector class</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.mgrit</span> <span class="kn">import</span> <span class="n">Mgrit</span>  <span class="c1"># MGRIT solver</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.grid_transfer</span> <span class="kn">import</span> <span class="n">GridTransfer</span>  <span class="c1"># Parent grid transfer class</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.grid_transfer_copy</span> <span class="kn">import</span> <span class="n">GridTransferCopy</span>  <span class="c1"># Copy transfer class</span>


<span class="c1"># Create class for the grid transfer between spatial grids.</span>
<span class="c1"># Note: The class must inherit from PyMGRIT&#39;s core GridTransfer class.</span>
<span class="k">class</span> <span class="nc">GridTransferHeat</span><span class="p">(</span><span class="n">GridTransfer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Grid Transfer class for the Heat Equation.</span>
<span class="sd">    Interpolation: Linear interpolation</span>
<span class="sd">    Restriction: Full weighting</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>
<span class="sd">        :rtype: GridTransferHeat object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="c1"># Define restriction operator</span>
    <span class="k">def</span> <span class="nf">restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorHeat1D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorHeat1D</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restrict input vector u using standard full weighting restriction.</span>

<span class="sd">        Note: In the 1d heat equation example, we consider homogeneous Dirichlet BCs in space.</span>
<span class="sd">              The Heat1D vector class only stores interior points.</span>
<span class="sd">        :param u: approximate solution vector</span>
<span class="sd">        :return: input solution vector u restricted to a coarse grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get values at interior points</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

        <span class="c1"># Create array for restricted values</span>
        <span class="n">ret_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Full weighting restriction</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)):</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>

        <span class="c1"># Create and return a VectorHeat1D object with the restricted values</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">VectorHeat1D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">))</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="c1"># Define interpolation operator</span>
    <span class="k">def</span> <span class="nf">interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorHeat1D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorHeat1D</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate input vector u using linear interpolation.</span>

<span class="sd">        Note: In the 1d heat equation example, we consider homogeneous Dirichlet BCs in space.</span>
<span class="sd">              The Heat1D vector class only stores interior points.</span>
<span class="sd">        :param u: approximate solution vector</span>
<span class="sd">        :return: input solution vector u interpolated to a fine grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get values at interior points</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

        <span class="c1"># Create array for interpolated values</span>
        <span class="n">ret_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Linear interpolation</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)):</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Create and return a VectorHeat1D object with interpolated values</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">VectorHeat1D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">))</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>


<span class="c1"># Construct a four-level multigrid hierarchy for the 1d heat example</span>
<span class="c1">#   * use a coarsening factor of 2 in time on all levels</span>
<span class="c1">#   * apply spatial coarsening by a factor of 2 on the first two levels</span>
<span class="n">heat0</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">heat1</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat0</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat2</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat1</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat3</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat2</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>

<span class="n">problem</span> <span class="o">=</span> <span class="p">[</span><span class="n">heat0</span><span class="p">,</span> <span class="n">heat1</span><span class="p">,</span> <span class="n">heat2</span><span class="p">,</span> <span class="n">heat3</span><span class="p">]</span>

<span class="c1"># Specify a list of grid transfer operators of length (#levels - 1) for the transfer between two consecutive levels</span>
<span class="c1">#   * Use the new class GridTransferHeat to apply spatial coarsening for transfers between the first three levels</span>
<span class="c1">#   * Use PyMGRIT&#39;s core class GridTransferCopy for the transfer between the last two levels (no spatial coarsening)</span>
<span class="n">transfer</span> <span class="o">=</span> <span class="p">[</span><span class="n">GridTransferHeat</span><span class="p">(),</span> <span class="n">GridTransferHeat</span><span class="p">(),</span> <span class="n">GridTransferCopy</span><span class="p">()]</span>

<span class="c1"># Setup four-level MGRIT solver and solve the problem</span>
<span class="n">mgrit</span> <span class="o">=</span> <span class="n">Mgrit</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="n">problem</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="n">transfer</span><span class="p">)</span>

<span class="n">info</span> <span class="o">=</span> <span class="n">mgrit</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="convergence-criteria">
<h2>Convergence criteria<a class="headerlink" href="#convergence-criteria" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_example_convergence_criterion.py">example_convergence_criterion.py</a></p>
<p>In this example, we define a customized version of PyMGRIT’s MGRIT solver that uses a different convergence criterion.
A two-level variant of this customized solver is then applied to compute an Arenstorf orbit.</p>
<p>All it takes to define a customized MGRIT solver is to create a new class that inherits from PyMGRIT’s core <cite>Mgrit</cite>
class and to define in this child class the method <cite>convergence_criterion()</cite>, overwriting <cite>Mgrit</cite>’s member routine
<cite>convergence_criterion()</cite> that is called in the algorithm after each iteration. In this example, we implement a
convergence criterion based on the maximum norm of the relative difference at C-points of successive iterates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MgritCustomized</span><span class="p">(</span><span class="n">Mgrit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Customized MGRIT class.</span>

<span class="sd">    Use maximum norm of the relative difference at C-points of two successive</span>
<span class="sd">    iterates as convergence criterion.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cumstomized MGRIT constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call parent constructor</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># New member variable for saving the C-point values of the last iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_it</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Initialize the new member variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_criterion</span><span class="p">(</span><span class="n">iteration</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convergence_criterion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iteration</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stopping criterion based on achieving a maximum relative difference at C-points</span>
<span class="sd">        of two successive iterates below the specified stopping tolerance.</span>
<span class="sd">        Note: The stopping tolerance is specified when setting up the solver.</span>

<span class="sd">        :param iteration: Iteration number</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create list in the first function call</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_it</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_local_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_local_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_values</span><span class="p">())))</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_it</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># If process has a C-point</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_local_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Loop over all C-points of the process</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_local_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">new</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Compute relative difference between two iterates</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">new</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_it</span><span class="p">),</span> <span class="n">new</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_it</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="n">new</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))))</span>

        <span class="c1"># Communicate the local value</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm_time</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="c1"># Take maximum norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
</pre></div>
</div>
<p>We can use the new class <cite>MgritCustomized</cite> to set up an MGRIT solver with the new convergence criterion and solve our
problem in the usual way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two-level time-grid hierarchy for the ODE system describing Arenstorf orbits</span>
<span class="n">ahrenstorf_lvl_0</span> <span class="o">=</span> <span class="n">ArenstorfOrbit</span><span class="p">(</span><span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mf">17.06521656015796</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">10001</span><span class="p">)</span>
<span class="n">ahrenstorf_lvl_1</span> <span class="o">=</span> <span class="n">ArenstorfOrbit</span><span class="p">(</span><span class="n">t_interval</span><span class="o">=</span><span class="n">ahrenstorf_lvl_0</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">100</span><span class="p">])</span>

<span class="c1"># Set up customized MGRIT solver and solve the problem.</span>
<span class="c1"># Note: Setting the solver tolerance to 1 means that iterations stop</span>
<span class="c1">#       if the maximum relative change at C-points of all four variables of the ODE system</span>
<span class="c1">#       is smaller than 1%.</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">MgritCustomized</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="p">[</span><span class="n">ahrenstorf_lvl_0</span><span class="p">,</span> <span class="n">ahrenstorf_lvl_1</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../applications/dahlquist.html" class="btn btn-neutral float-right" title="Dahlquist" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="parallelism.html" class="btn btn-neutral float-left" title="Parallelism" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Jens Hahne and Stephanie Friedhoff

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>